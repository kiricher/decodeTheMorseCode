<html>

<head>
    <title>
        Код морзе
    </title>
</head>
<script>
    let str = "00000000000111111100000011010001110111000000001110000000000000000001111111011111100001101111100000111100111100011111100000001011100000011111110010001111100110000011111100101111100000000000000111111100001111010110000011000111110010000011111110001111110011111110000010001111110001111111100000001111111101110000000000000010110000111111110111100000111110111110011111110000000011111001011011111000000000000111011111011111011111000000010001001111100000111110111111110000001110011111100011111010000001100001001000000000000000000111111110011111011111100000010001001000011111000000100000000101111101000000000000011111100000011110100001001100000000001110000000000000001101111101111000100000100001111111110000000001111110011111100011101100000111111000011011111000111111000000000000000001111110000100110000011111101111111011111111100000001111110001111100001000000000000000000000000000000000000000000000000000000000000";
    function getSignals(strOfMorse) {

        const START = 0;
        const DELETEOFNULLS = 1;
        const COUNTOFONE = 2;
        const COUNTOFNULL = 3;
        const EXIT = 4;

        let index = 0
        let stage = START;
        let arrOfCode = [];
        while (stage != EXIT) {
            let count = 0;
            let isIndexNotLength;
            switch (stage) {
                case START:
                    if (strOfMorse[index] == '0') {
                        stage = DELETEOFNULLS;
                    } else {
                        stage = COUNTOFONE;
                    }
                    break;

                case DELETEOFNULLS:
                    while (strOfMorse[index] != '1') {
                        index += 1;
                    }
                    stage = COUNTOFONE;
                    break;

                case COUNTOFONE:
                    count = 0;
                    let isNotNull = strOfMorse[index] != '0';
                    isIndexNotLength = strOfMorse.length != index;

                    while (isNotNull && isIndexNotLength) {
                        count += 1;
                        index += 1;
                        isNotNull = strOfMorse[index] != '0';
                        isIndexNotLength = strOfMorse.length != index;
                    }
                    arrOfCode.push(
                        {
                            "signal": count,
                            "type": 1,
                        });
                    if (isIndexNotLength) {
                        stage = COUNTOFNULL;
                    } else {
                        stage = EXIT;
                    }

                    break;
                case COUNTOFNULL:
                    count = 0;
                    let isNotOne = strOfMorse[index] != '1';
                    isIndexNotLength = strOfMorse.length != index;

                    while (isNotOne && isIndexNotLength) {
                        count += 1;
                        index += 1;
                        isIndexNotLength = strOfMorse.length != index;
                        isNotOne = strOfMorse[index] != '1';
                    }
                    arrOfCode.push(
                        {
                            "signal": count,
                            "type": 0,
                        });
                    if (isIndexNotLength) {
                        stage = COUNTOFONE;
                    } else {
                        stage = EXIT;
                    }

                    break;
            }
        }
        if (arrOfCode[arrOfCode.length - 1]['type'] == 0) {
            arrOfCode.pop();
        }
        return arrOfCode;
    }

    function findBigSpace(arrayOfSignals) {
        let max = 0;
        arrayOfSignals.forEach(element => {
            if (element.signal > max) {
                if (element['type'] == 0)
                    max = element.signal;
            }
        })
        arrayOfSignals.forEach(element => {
            if ((element['type'] == 0) && (element.signal == max)) {
                element.type = 3;
            }
        })
    }
    function getMaxAndMins(arrayOfSignals) {
        let minOfNulls = 9999999999;
        let minOfOnes = 99999999999;

        let maxOfNulls = 0;
        let maxOfOnes = 0;
        arrayOfSignals.forEach(element => {
            if (element['type'] == 0) {
                if (element.signal < minOfNulls) {
                    minOfNulls = element.signal
                }
                if (element.signal > maxOfNulls) {
                    maxOfNulls = element.signal;
                }
            }
            if (element['type'] == 1) {
                if (element.signal < minOfOnes) {
                    minOfOnes = element.signal
                }
                if (element.signal > maxOfOnes) {
                    maxOfOnes = element.signal;
                }
            }
        });
        return {
            'minOfNulls': minOfNulls,
            'maxOfNulls': maxOfNulls,
            'minOfOnes': minOfOnes,
            'maxOfOnes': maxOfOnes,
        }
    }

    function getDotOrdash(max, min, signal) {
        if (Math.abs(max - signal) <= Math.abs(min - signal)) {
            return '-';
        }
        else {
            return '.';
        }
    }

    function getSpaces(max, min, avr, signal) {
        if (Math.abs(signal - min) < Math.abs(signal - avr)) {
            return "";
        } else if (Math.abs(signal - avr) < (Math.abs(signal - max))) {
            return " ";
        } else {
            return "  ";
        }
    }

    function getMorseCode(arr) {
        str = "";
        let maxAndMins = getMaxAndMins(arr);
        let minOfNulls = maxAndMins['minOfNulls'];
        let maxOfNulls = maxAndMins['maxOfNulls'];
        let maxOfOnes = maxAndMins['maxOfOnes'];
        let minOfOnes = maxAndMins['minOfOnes'];
        console.log(arr.filter((item)=> item["type"] == "0"));
        let average = getAverage(arr.filter((item)=> item["type"] == "0").map((item)=> item.signal));
        let sym;
        arr.forEach(function (element) {
            if (element['type'] == 0) {
                sym = getSpaces(maxOfNulls, minOfNulls, average, element.signal);
                str = str.concat(sym);
            }
            if (element['type'] == 1) {
                sym = getDotOrdash(maxOfOnes, minOfOnes, element.signal);
                str = str.concat(sym);
            }
        });
        return str;
    }
    arr = getSignals(str);
    console.log(getMorseCode(arr));

    function getAverage(arr) {
        let max = arr.reduce((max, item) => item > max ? item : max, arr[0]);
        let min = arr.reduce((min, item) => item < min ? item : min, arr[0]);
        let number = 0;
        let minDistance = 999999999;
        let p1;
        let p2;
        let distance;
        arr.forEach((item) => {
            p1 = item - min;
            p2 = max - item;
            distance = Math.abs(p2 - p1);
            if (distance < minDistance) {
                minDistance = distance;
                number = item;
            }
        })
        return number;
    }
</script>

<body>
    1111111    - 
    000000   " "
    11   .  
    0   ""
    1    .
    000 ""
    111  .
    0 ""
    111  .
    00000000 " "
    111  .
    000000000000000000 " "
    1111111 -
    0
    111111 -
    0000 ""
    11  .
    0
    11111 -
    00000 ""
    1111 -
    00  ""
    1111 .
    000 ""
    111111 -
    0000000 " "
    1
    0   ""
    111
    000000 " "
    1111111
    00 ""
    1 
    0001111100110000011111100101111100000000000000111111100001111010110000011000111110010000011111110001111110011111110000010001111110001111111100000001111111101110000000000000010110000111111110111100000111110111110011111110000000011111001011011111000000000000111011111011111011111000000010001001111100000111110111111110000001110011111100011111010000001100001001000000000000000000111111110011111011111100000010001001000011111000000100000000101111101000000000000011111100000011110100001001100000000001110000000000000001101111101111000100000100001111111110000000001111110011111100011101100000111111000011011111000111111000000000000000001111110000100110000011111101111111011111111100000001111110001111100001000000000000000000000000000000000000000000000000000000000000
</body>

</html>